---
layout: post
title: A scenario where tests help facilitate compatibility and communication
tag:
---

<h3>Short History Lesson</h3>
<p>
  Let's start off with some backstory: there was a time when only one Ruby implementation existed in the world:
  Matz's own Ruby Interpreter (MRI) written purely in C. Some time later, JRuby arrived onto the scene and,
  while it was still in its infancy, an announcement was made by <a href="http://twitter.com/evanphx">Evan Phoenix</a>
  for a project called <a href="http://rubini.us/">Rubinius</a>.
</p> 
<p>
  Rubinius was not just an ordinary Ruby implementation; it was an implementation with a goal to be written in Ruby
  as much as possible, inspired and modeled off of Smalltalk-80. Soon thereafter, <a href="http://github.com/brixen">Brian Ford</a>
  joined forces with Phoenix to continue Rubinius development under Engine Yard and to work on a specialized framework
  called <a href="http://github.com/rubyspec/mspec">MSpec</a>.
</p>
<p>
  This simplistic framework allowed the Rubinius team to create tests of "correct behaviors" found in MRI and to
  mimic those results in Rubinius. It was a basic idea designed to measure the progress of the project, and it reaped
  rewards far more than originally anticipated. <a href="http://rubyspec.org/">RubySpec</a> became the name of the collection of
  &rquo;correct behavior&lquo; tests and the executable specification for all implementations in the Ruby ecosystem.
</p>  
<p>
  By having all implementations follow the standard definition of Ruby (which in this case were MRI and KRI aka YARV),
  programmers would be able to move around to different implementations with ease and confidence.
</p>
<h3>RubySpec on Communication</h3>
<p>
  As it stands, all Ruby implementations adhere to RubySpec. We now know how RubySpec facilitates compatibility
  among each implementation, but how does it facilitate communication?  RubySpec tests are not only intended to be
  executed against implementations, but like any other open source project, it fosters contributions. 
</p>
<p>
  Implementers and even developers are encouraged to add tests to RubySpec to enhance and increase the value and
  quality of the test suite.  By adding tests, it creates <a href="http://groups.google.com/group/rubyspec/">an opportunity</a>
  for implementers of different implementations to talk to each other. This is what I would call a symbiotic relationship,
  one where all implementers have a common goal to make their implementations look and feel the same as MRI/KRI. 
</p>
<h3>The Case of Other Languages</h3>
<p>
  Unfortunately, this symbiotic relationship does not appear in other languages such as JavaScript and Smalltalk (at least not yet). 
  JavaScript implementers took the specification from ECMA 
  (<a href="http://www.ecma-international.org/publications/standards/Ecma-262-arch.htm">ECMA-262, Edition 3</a>),
  complied with <a href="http://en.wikipedia.org/wiki/Comparison_of_layout_engines_" title="ECMAScript">most of what was in the specification</a>,
  and added their own language feature set on top.
</p>
<p> 
  Over time, after revisions and rewrites of their <a href="http://en.wikipedia.org/wiki/JavaScript_engine">JavaScript engines</a>,
  it became difficult, from a developer standpoint, to distinguish between what was originally part of ECMAScript and what was part
  of the implementation.  Perhaps that was never the goal of ECMAScript, but the language slowly became fragmented, if ever so slightly,
  and developers found it challenging to switch between platforms (in this case, browsers). 
</p>
<p>
  Smalltalk implementers also took the specification from <a href="http://en.wikipedia.org/wiki/Parc_Place_Systems">ParcPlace</a>
  (<a href="http://www.smalltalk.org/versions/ANSIStandardSmalltalk.html">Smalltalk ANSI standard</a>) and proceeded in
  different directions, never to look back.  If you search the words, "Smalltalk" and "Balkanization", you will
  come up with some interesting <a href="http://www.threeriversinstitute.org/blog/?p=466">articles</a> on why
  Smalltalk did not really take off.
</p>
<p>
  While some will argue that both JavaScript and Smalltalk are backed by proprietary vendors and, therefore, not in their
  best interests, Ruby has proprietary vendors as well.  Fortunately, though, nearly all of the implementations are open sourced
  and all of them use RubySpec.
</p>
<p>
  Companies like Engine Yard, Microsoft, Apple, and Gemstone have created their own implementations and, while only two of
  them are fully implemented, developers are excited about using them and have confidence that the language they have grown
  to love will work the same in the new implementation.
</p>
<h3>What Can Be Done (Or Is It Too Late)?</h3>
<p>
  Thanks to JavaScript developers like <a href="http://perfectionkills.com/">Juriy Zaytsev</a>, there is a 
  <a href="http://kangax.github.com/cft/">set of tests</a> that  implementers can use to find common ground
  in the JavaScript language. 
</p>
<p>
  There is also the <a href="http://en.wikipedia.org/wiki/Sputnik_" title="JavaScript_conformance_test">Sputnik</a>
  test suite which determines how well an implementation adheres to ECMA-262, 3rd Edition.  Of course, it is up to
  the implementers to consider trying to find common ground, but having a set of tests will reveal
  incompatibilities across JavaScript implementations.
</p>
<p>
  For Smalltalk, there has been apparently <a href="http://www.threeriversinstitute.org/blog/?p=466">more converging
  than diverging in the past decade</a>, but we may never see the light at the end of the tunnel.  Now reaching
  its thirties, finding a common ground may prove to be difficult.
</p>  
<p>
  As of yet, there is no standard test suite that all Smalltalk implementers use and, as a result, communication 
  through tests does not occur.  It may be too late because of the complexity involved with each implementation.
</p>
<p>
  The only thing Smalltalk implementers have going for them is whether or not Seaside runs on their implementation,
  similar to how Ruby implementations use Rails ("The Rails Singularity") to test their own implementations.  
</p>
<h3>Final Thoughts</h3>
<p>
  As you can see, tests can play a major role in software development. Not only does it give confidence about
  the code and design, but also allows communication, similar to acceptance tests.  This is one particular case
  where tests can help a language ecosystem thrive and sustain compatibility and communication.
</p>
<p>  
  I propose this is one of the reasons why we love Ruby so much.  Having common ground allows developers
  to fiddle with different implementations without worrying about syntactical issues, but at the same 
  time, having the confidence that their code will work much the same way as it did from one implementation to another.
</p>
<h3>References</h3>
<ul>
  <li>
    <a href="http://blog.brightredglow.com/2009/3/3/what-is-rubyspec">What is RubySpec?</a>
  </li>
  <li>
    <a href="http://www.akitaonrails.com/2008/02/11/chatting-with-evan-phoenix">Chatting with Evan Phoenix</a>
  </li>
  <li>
    <a href="http://blog.emptyway.com/2008/04/27/the-value-of-the-rubyspecs/">The Value of the RubySpecs</a>
  </li>
  <li>
    <a href="http://www.threeriversinstitute.org/blog/?p=466">Smalltalk: Welcome to the Balkans</a>
  </li>
  <li>
    <a href="http://en.wikipedia.org/wiki/Nash_equilibrium">Nash Equilibrium</a>
  </li>
  <li>
    <a href="http://www.jarober.com/blog/blogView?showComments=true&printTitle=Balkanization_and_Smalltalk&entry=3443331580">Smalltalk and Balkinzation</a>
  </li>
  <li>
    <a href="http://en.wikipedia.org/wiki/JavaScript_engine">JavaScript Engine</a>
  </li>
  <li>
    <a href="http://en.wikipedia.org/wiki/List_of_ECMAScript_engines">List of ECMAScript Engines</a>
  </li>
</ul>